import { App, Plugin, PluginSettingTab, Setting, debounce } from 'obsidian';
import { CustomIconSettings, SidebarIcons, FolderIcons, DEFAULT_SETTINGS, EMPTY_PNG_DATA_URL, DEFAULT_FOLDER_ICON } from './types';
import { generateUniqueId, updatePreview, convertToCamelCase } from './utils/utils';
import { Locals } from './i18n/i18n';
import { LocalProperty } from './i18n/types';
import * as lucideIcons from 'lucide-static';
import { FolderSuggest } from './settings/folderSuggester';

const css_filename = "CustomIcon-AutoGen";

export default class CustomIconPlugin extends Plugin {
    settings: CustomIconSettings;
    resourceBase: string;
    
    async onload() {
        await this.loadSettings();
        this.registerEvent(
            this.app.workspace.on('layout-change', () => {
                this.refreshSidebarIcons();
            })
        );
        this.addSettingTab(new CustomIconSettingTab(this.app, this));
        await this.genSnippetCSS(this);
    }

    onunload() {
        // @ts-ignore
        const customCss = plugin.app.customCss;
		customCss.enabledSnippets.remove(css_filename);
        customCss
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
        this.migrateData();
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }

    migrateData() {
        if (this.settings.customIcons && this.settings.customIcons.length > 0) {
            this.settings.SidebarIcons = [...this.settings.SidebarIcons, ...this.settings.customIcons];
            delete (this.settings as { customIcons?: unknown }).customIcons;
            this.saveSettings();
        }
    }

    async genSnippetCSS(plugin: CustomIconPlugin) {
        const content: string[] = [
			"/* * WARNING: This file will be overwritten by plugin `Custom Icon`.",
			"   * DO NOT EDIT THIS FILE DIRECTLY!!!",
			"   * Do not edit this file directly!!!",
			"*/",
			"",
		];
        plugin.settings.SidebarIcons.forEach(iconSetting => {
            content.push(this.genSidebarIconsEntryCSS(iconSetting));
        });
        plugin.settings.FolderIcons.forEach(iconSetting => {
            content.push(this.genFolderIconsEntryCSS(iconSetting));
        });

        const vault = plugin.app.vault;
		const ob_config_path = vault.configDir;
		const snippets_path = ob_config_path + "/snippets";

		const path = `${snippets_path}/${css_filename}.css`;
		if (!(await vault.adapter.exists(snippets_path))) { await vault.adapter.mkdir(snippets_path); }
		if (await vault.adapter.exists(path)) { await vault.adapter.remove(path) }
		await plugin.app.vault.create(path, content.join('\n'));
		// Activate snippet
		// @ts-ignore
		const customCss = plugin.app.customCss;
		customCss.enabledSnippets.add(css_filename);
		customCss.requestLoadSnippets();
    }

    genSidebarIconsEntryCSS(settings: SidebarIcons): string {
        const selector = `aria-label="${settings.label}"`;
        const iconUrl = this.getResourcePathwithType(settings.image, settings.type);
        let body: string[] = [
            `.custom-icon.workspace-tab-header[${selector}] .workspace-tab-header-inner-icon::before {`,
            `content: '';`,
            `display: inline-block;`,
            `width: 1em;`,
            `height: 1em;`,
            `background-color: transparent;`,
            `background-blend-mode: normal;`,
            `background-image: url("${iconUrl}");`,
            `background-size: contain;`,
            `background-repeat: no-repeat;`,
            `background-position: center;`,
            `}`,
        ];
        return body.join('\n');
    }
    genFolderIconsEntryCSS(settings: FolderIcons): string {
        const selector = `data-path="${settings.path}"`;
        const iconUrl = this.getResourcePathwithType(settings.image, settings.type);
        let body: string[] = [
            `.nav-folder-title[${selector}] .nav-folder-title-content::before {`,
            `content: '';`,
            `display: inline-block;`,
            `width: 16px;`,
            `height: 16px;`,
            `margin: -2px 0px -4px 0px;`,
            `background-color: transparent;`,
            `background-blend-mode: normal;`,
            `background-image: url("${iconUrl}");`,
            `background-size: contain;`,
            `background-repeat: no-repeat;`,
            `}`,
        ];
        return body.join('\n');
    }

    svgToDataURI(svgContent: string): string {
        const encodedSVG = encodeURIComponent(svgContent);
        const dataURI = `data:image/svg+xml;charset=utf-8,${encodedSVG}`;
        return dataURI;
    }
    
    getResourcePath(path: string): string {
        let resourcePath = this.app.vault.adapter.getResourcePath("");
		this.resourceBase = resourcePath.match(/(app:\/\/\w*?)\//)?.[1] as string;

        if (/^(https?:\/\/|data:)/.test(path)) {
            return path;
        }
    
        if (path.startsWith("<svg")) {
            return this.svgToDataURI(path);
        }
    
        const adapter = this.app.vault.adapter;
    
        if (path.startsWith("/")) {
            return this.resourceBase + path;
        } else if (/^[c-zC-Z]:[\/\\]/.test(path)) {
            return this.resourceBase +path.replace(/\\/g, '/').replace(/^([c-zC-Z]):/, '/$1:')
        } else {
            return adapter.getResourcePath(path);
        }
    }

    getLucidePath(iconName: string): string {
        const camelCaseIconName = convertToCamelCase(iconName);
        const iconSvg = lucideIcons[camelCaseIconName as keyof typeof lucideIcons];
        return this.svgToDataURI(iconSvg);
    }

    getResourcePathwithType(path: string, type: string): string {
        let PATH = path.trim();
        switch(type){
            case 'custom':
                PATH = this.getResourcePath(path);
                break;
            case 'lucide':
                PATH = this.getLucidePath(path);
                break;
            default:
                PATH = this.getResourcePath(EMPTY_PNG_DATA_URL);
                break;
        }
        return PATH;
    }

    refreshSidebarIcons() {
        this.settings.SidebarIcons.forEach(icon => {
            document.querySelectorAll(`.workspace-tab-header[aria-label="${icon.label}"]`)
                .forEach(tabHeader => {
                    tabHeader.classList.add('custom-icon');
                    tabHeader.setAttribute('data-icon-id', icon.id);
                });
        });
        
    }
}

export class CustomIconSettingTab extends PluginSettingTab {
    plugin: CustomIconPlugin;
    activeTab: string = 'SidebarIcons';
    debouncedGenerate: Function;

    constructor(app: App, plugin: CustomIconPlugin) {
        super(app, plugin);
        this.plugin = plugin;
        this.debouncedGenerate = debounce(this.generateSnippet, 1000, true);
    }
    async generateSnippet() {
		await this.plugin.genSnippetCSS(this.plugin);
	}

    display(): void {
        const { containerEl } = this;
        const t = Locals.get();

        containerEl.empty();
        const settingsTitle = containerEl.createEl('div', {cls: 'csbi-setting-title'});
        settingsTitle.createEl('h1', {text: `${t.Tab_Title}`});

        const settingsTabHeader = containerEl.createEl('nav', {cls: 'csbi-setting-header'});
        const tabGroup = settingsTabHeader.createEl('div', {cls: 'csbi-setting-tab-group'})

        const SidebarIconsTab = tabGroup.createEl('div', {cls: `csbi-tab ${this.activeTab === 'SidebarIcons' ? 'csbi-tab-active' : ''}`, text: `${t.Tab_SidebarIcons}`});
        SidebarIconsTab.addEventListener('click', () => {
            this.activeTab = 'SidebarIcons';
            this.display();
        });
        const FolderIconsTab = tabGroup.createEl('div', {cls: `csbi-tab ${this.activeTab === 'FolderIcons' ? 'csbi-tab-active' : ''}`, text: `${t.Tab_FolderIcons}`});
        FolderIconsTab.addEventListener('click', () => {
            this.activeTab = 'FolderIcons';
            this.display();
        });
        const AboutTab = tabGroup.createEl('div', {cls: `csbi-tab ${this.activeTab === 'About' ? 'csbi-tab-active' : ''}`, text: `${t.Tab_About}`});
        AboutTab.addEventListener('click', () => {
            this.activeTab = 'About';
            this.display();
        });

        const settingsContent = containerEl.createEl('div', {cls: 'csbi-setting-content'});
        const settingsFill = settingsTabHeader.createEl('div', {cls: 'csbi-fill'});

        switch (this.activeTab) {
            case 'SidebarIcons':
                this.displaySidebarIcons(settingsContent, t);
                break;
            case 'FolderIcons':
                this.displayFolderIcons(settingsContent, t);
                break;
            case 'About':
                this.displayAbout(settingsContent, t);
                break;
            default:
                break;
        }
    }

    displaySidebarIcons(containerEl: HTMLElement, t: LocalProperty): void {      
        this.plugin.settings.SidebarIcons.forEach((icon, index) => {
            let previewEl: HTMLDivElement;

            const iconSetting = new Setting(containerEl)
                .setName(t.IconID.replace('{num}', `${icon.id}`))

            iconSetting.addText(text => {
                text
                    .setValue(icon.label)
                    .setPlaceholder(t.SidebarIcons_FileName)
                    .onChange(async (value) => {
                        icon.label = value;
                        await this.plugin.saveSettings();
                        this.plugin.refreshSidebarIcons();
                        this.debouncedGenerate();                        
                    })
            });
            iconSetting.addDropdown(dropdown => {
                dropdown
                    .addOption('custom', t.Type_Custom)
                    .addOption('lucide', t.Type_Lucide)
                    .setValue(icon.type || 'custom')
                    .onChange(async (value) => {
                        icon.type = value;
                        await this.plugin.saveSettings();
                        let image = icon.image || EMPTY_PNG_DATA_URL;
                        updatePreview(previewEl, this.plugin.getResourcePathwithType(image, icon.type) );
                    })
            });
            iconSetting.addTextArea(textArea => {
                previewEl = createDiv({ cls: 'icon-preview' });
                textArea.inputEl.parentElement?.prepend(previewEl);
                textArea
                    .setValue(icon.image)
                    .setPlaceholder(t.IconImg)
                    .onChange(async (value) => {
                        icon.image = value;
                        await this.plugin.saveSettings();
                        this.plugin.refreshSidebarIcons();
                        this.debouncedGenerate();
                        updatePreview(previewEl, this.plugin.getResourcePathwithType((icon.image.trim() || EMPTY_PNG_DATA_URL), icon.type) );
                    })
                updatePreview(previewEl, this.plugin.getResourcePathwithType((icon.image.trim() || EMPTY_PNG_DATA_URL), icon.type) );
            });
            iconSetting.addButton(button => {
                button
                    .setButtonText(t.RemoveIconButton)
                    .setCta()
                    .onClick(async () => {
                        const tabHeaderElement = document.querySelector(`.workspace-tab-header[data-icon-id="${icon.id}"]`);
                        tabHeaderElement?.classList.remove('custom-icon');
                        tabHeaderElement?.removeAttribute('data-icon-id');
                        this.debouncedGenerate();

                        this.plugin.settings.SidebarIcons.splice(index, 1);
                        await this.plugin.saveSettings();
                        this.display();
                    })
            });
        });

        new Setting(containerEl)
            .addButton(button =>
                button
                    .setButtonText(t.AddIconButton)
                    .onClick(async () => {
                        this.plugin.settings.SidebarIcons.push({
                            id: generateUniqueId(),
                            label: '',
                            image: '',
                            type: "custom"
                        });
                        await this.plugin.saveSettings();
                        this.display();
                    })
        );
    }

    displayFolderIcons(containerEl: HTMLElement, t: LocalProperty): void {


        this.plugin.settings.FolderIcons.forEach((icon, index) => {
            let previewEl: HTMLDivElement;

            const iconSetting = new Setting(containerEl)
                .setName(t.IconID.replace('{num}', `${icon.id}`))
            
            iconSetting.addSearch(search => {
                new FolderSuggest(search.inputEl);
                search
                    .setPlaceholder(t.FolderIcons_FileName)
                    .setValue(icon.path)
                    .onChange(path => {
                        icon.path = path;
                        this.plugin.saveSettings();
                        this.debouncedGenerate();
                        let image = icon.image || EMPTY_PNG_DATA_URL;
                        updatePreview(previewEl, this.plugin.getResourcePathwithType(image, icon.type));
                    })
            });
        
            iconSetting.addDropdown(dropdown => {
                dropdown
                    .addOption('custom', t.Type_Custom)
                    .addOption('lucide', t.Type_Lucide)
                    .setValue(icon.type || 'custom')
                    .onChange(async (value) => {
                        icon.type = value;
                        await this.plugin.saveSettings();
                        this.debouncedGenerate();
                        let image = icon.image || DEFAULT_FOLDER_ICON;
                        updatePreview(previewEl, this.plugin.getResourcePathwithType(image, icon.type));
                    })
            });
            iconSetting.addTextArea(textArea => {
                previewEl = createDiv({ cls: 'icon-preview' });
                textArea.inputEl.parentElement?.prepend(previewEl);
                textArea
                    .setValue(icon.image)
                    .setPlaceholder(t.IconImg)
                    .onChange(async (value) => {
                        icon.image = value;
                        await this.plugin.saveSettings();
                        this.debouncedGenerate();
                        updatePreview(previewEl, this.plugin.getResourcePathwithType((icon.image.trim() || DEFAULT_FOLDER_ICON), icon.type));
                    })
                updatePreview(previewEl, this.plugin.getResourcePathwithType((icon.image.trim() || DEFAULT_FOLDER_ICON), icon.type));
            });
            iconSetting.addButton(button => {
                button
                    .setButtonText(t.RemoveIconButton)
                    .setCta()
                    .onClick(async () => {
                        const tabHeaderElement = document.querySelector(`.nav-folder-title[data-icon-id="${icon.id}"]`);
                        tabHeaderElement?.classList.remove('custom-icon');
                        tabHeaderElement?.removeAttribute('data-icon-id');
                        this.debouncedGenerate();

                        this.plugin.settings.FolderIcons.splice(index, 1);
                        await this.plugin.saveSettings();
                        this.display();
                    })
            });
        });

        new Setting(containerEl)
            .addButton(button =>
                button
                    .setButtonText(t.AddIconButton)
                    .onClick(async () => {
                        this.plugin.settings.FolderIcons.push({
                            id: generateUniqueId(),
                            path: '',
                            image: `${DEFAULT_FOLDER_ICON}`,
                            type: "custom"
                        });
                        await this.plugin.saveSettings();
                        this.display();
                    })
        );
    }

    displayAbout(containerEl: HTMLElement, t: LocalProperty): void {
        const pEl = containerEl.createEl('div');
        pEl.setAttribute("style", "color: gray; font-size: 12px;");
        pEl.innerHTML = t.About;
    }
}
